"use strict";(self.webpackChunkguidelines=self.webpackChunkguidelines||[]).push([[464],{3060:(e,n,t)=>{t.r(n),t.d(n,{assets:()=>d,contentTitle:()=>r,default:()=>p,frontMatter:()=>o,metadata:()=>a,toc:()=>c});var s=t(4848),i=t(8453);const o={sidebar_position:3},r="Constants and Variable Types",a={id:"conventions/types",title:"Constants and Variable Types",description:"We adopted a rule to always use explicit variable size. So the usage of int, unsigned int, long and short is not advised.",source:"@site/docs/conventions/types.md",sourceDirName:"conventions",slug:"/conventions/types",permalink:"/guidelines/docs/conventions/types",draft:!1,unlisted:!1,tags:[],version:"current",sidebarPosition:3,frontMatter:{sidebar_position:3},sidebar:"tutorialSidebar",previous:{title:"Braces(backets) scoping",permalink:"/guidelines/docs/conventions/braces"},next:{title:"Comments",permalink:"/guidelines/docs/conventions/comments"}},d={},c=[{value:"Example for the esp32 system:",id:"example-for-the-esp32-system",level:4}];function l(e){const n={code:"code",h1:"h1",h4:"h4",header:"header",p:"p",pre:"pre",...(0,i.R)(),...e.components};return(0,s.jsxs)(s.Fragment,{children:[(0,s.jsx)(n.header,{children:(0,s.jsx)(n.h1,{id:"constants-and-variable-types",children:"Constants and Variable Types"})}),"\n",(0,s.jsxs)(n.p,{children:["We adopted a rule to always use explicit variable size. So the usage of ",(0,s.jsx)(n.code,{children:"int"}),", ",(0,s.jsx)(n.code,{children:"unsigned int"}),", ",(0,s.jsx)(n.code,{children:"long"})," and ",(0,s.jsx)(n.code,{children:"short"})," is not advised.\nThe reason for this is that, a ",(0,s.jsx)(n.code,{children:"int"})," for example, is not always guranteed to be 32 bits. In a microcontroller like some versions of PIC is 16 bits."]}),"\n",(0,s.jsxs)(n.p,{children:["We opted to use a convention for integer types similar to the ones in the rust programming language, where a type begin with ",(0,s.jsx)(n.code,{children:"i"})," for integer and ",(0,s.jsx)(n.code,{children:"u"})," for unsigned.\nEven tho theres already a C standard header file for this, the standard way is quite verbose."]}),"\n",(0,s.jsx)(n.h4,{id:"example-for-the-esp32-system",children:"Example for the esp32 system:"}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-cpp",children:"typedef unsigned char u8; // 8 bits, unsigned\ntypedef signed char  i8; // 8 bits, signed\n\ntypedef uint16_t u16; // 16 bits, unsigned\ntypedef int16_t  i16; // 16 bits, signed\n\ntypedef unsigned int u32; // 32 bits, unsigned\ntypedef int          i32; // 32 bits, signed\n\ntypedef uint64_t u64; // 64 bits, unsigned\ntypedef int64_t  i64; // 64 bits, signed\n\ntypedef float  f32; // 32 bits floating point\ntypedef double f64; // 64 bits floating point\n\ntypedef unsigned char byte; // 8bit sized type\n"})}),"\n",(0,s.jsxs)(n.p,{children:["There is a header file containing the ",(0,s.jsx)(n.code,{children:"integer"})," type nomeclatures in the root of this repo, one should use this file and change the ",(0,s.jsx)(n.code,{children:"typedefs"})," so that the sizes always mathch."]})]})}function p(e={}){const{wrapper:n}={...(0,i.R)(),...e.components};return n?(0,s.jsx)(n,{...e,children:(0,s.jsx)(l,{...e})}):l(e)}},8453:(e,n,t)=>{t.d(n,{R:()=>r,x:()=>a});var s=t(6540);const i={},o=s.createContext(i);function r(e){const n=s.useContext(o);return s.useMemo((function(){return"function"==typeof e?e(n):{...n,...e}}),[n,e])}function a(e){let n;return n=e.disableParentContext?"function"==typeof e.components?e.components(i):e.components||i:r(e.components),s.createElement(o.Provider,{value:n},e.children)}}}]);