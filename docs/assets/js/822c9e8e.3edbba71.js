"use strict";(self.webpackChunkguidelines=self.webpackChunkguidelines||[]).push([[23],{5234:(e,n,o)=>{o.r(n),o.d(n,{assets:()=>l,contentTitle:()=>i,default:()=>m,frontMatter:()=>a,metadata:()=>s,toc:()=>c});var t=o(4848),r=o(8453);const a={sidebar_position:2},i="Dynamic memory allocation and heap usage",s={id:"features/dyn_memory",title:"Dynamic memory allocation and heap usage",description:"Dynamic memory allocation, either by the C style malloc, or with the C++ new operator is discouraged.",source:"@site/docs/features/dyn_memory.md",sourceDirName:"features",slug:"/features/dyn_memory",permalink:"/guidelines/docs/features/dyn_memory",draft:!1,unlisted:!1,tags:[],version:"current",sidebarPosition:2,frontMatter:{sidebar_position:2},sidebar:"tutorialSidebar",previous:{title:"Exceptions",permalink:"/guidelines/docs/features/exceptions"},next:{title:"Preprocessor usage",permalink:"/guidelines/docs/features/preprocessor"}},l={},c=[{value:"Example, initializing classes for a project.",id:"example-initializing-classes-for-a-project",level:4}];function d(e){const n={code:"code",h1:"h1",h4:"h4",header:"header",p:"p",pre:"pre",...(0,r.R)(),...e.components};return(0,t.jsxs)(t.Fragment,{children:[(0,t.jsx)(n.header,{children:(0,t.jsx)(n.h1,{id:"dynamic-memory-allocation-and-heap-usage",children:"Dynamic memory allocation and heap usage"})}),"\n",(0,t.jsxs)(n.p,{children:["Dynamic memory allocation, either by the C style ",(0,t.jsx)(n.code,{children:"malloc"}),", or with the C++ ",(0,t.jsx)(n.code,{children:"new"})," operator is discouraged."]}),"\n",(0,t.jsx)(n.p,{children:"Dynamic memory allocation is hard for static code analyzers to catch bugs and results in a less predictable heap usage.\nWhenever possible, try to allocate memory statically."}),"\n",(0,t.jsx)(n.h4,{id:"example-initializing-classes-for-a-project",children:"Example, initializing classes for a project."}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-cpp",children:'\n#include "core/controller.h"\n#include "core/foo.h"\n#include "base/bar.h"\n\n[[noreturn]] void staticAllocation() // prefered.\n{\n    // While using static varables like this, we can easily predic the amount of\n    // heap usage during compile time.\n\n    static Foo foo{};\n    static Bar bar{};\n\n    static Controller controller{foo, bar};\n\n    for(;;)\n    {\n        controller.doSomething();\n    }\n}\n\n\n[[noreturn]] void dynamicAllocation() // discouraged\n{\n    // Those are some methods to dynamically allocate memory in modern C++.\n    // Those methods results in a unpredictable heap usage since it will be\n    // only initialized during run time.\n\n    Foo *foo = new Foo();\n    Bar *bar = static_cast<Bar*>(malloc(sizeof(Bar)));\n\n    // Some of those methods also results in a harder to read syntax.\n    std::unique_ptr<Controller> controller =\n        std::make_unique(new Controller(foo, bar));\n\n    for(;;)\n    {\n        controller->doSomething();\n    }\n}\n\n'})})]})}function m(e={}){const{wrapper:n}={...(0,r.R)(),...e.components};return n?(0,t.jsx)(n,{...e,children:(0,t.jsx)(d,{...e})}):d(e)}},8453:(e,n,o)=>{o.d(n,{R:()=>i,x:()=>s});var t=o(6540);const r={},a=t.createContext(r);function i(e){const n=t.useContext(a);return t.useMemo((function(){return"function"==typeof e?e(n):{...n,...e}}),[n,e])}function s(e){let n;return n=e.disableParentContext?"function"==typeof e.components?e.components(r):e.components||r:i(e.components),t.createElement(a.Provider,{value:n},e.children)}}}]);